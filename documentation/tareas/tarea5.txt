### F5 – Persistencia Postgres Mínima (chem-persistence)

Propósito: lograr durabilidad en Postgres con paridad 1:1 frente al backend en memoria, manteniendo el determinismo del motor y aislando los mapeos dominio↔filas.

GATE_F5 (Criterios de aceptación):
- Replay DB = Replay memoria (mismo estado, fingerprints y secuencia de eventos).
- Sin divergencias en eventos (mismos `event_variants` y conteos).

Precondiciones/prerrequisitos:
- `DATABASE_URL` válido (Postgres accesible). Puede usarse `postgress-docker/compose.yaml` para entorno local.
- `chem-core` F2 estable (eventos, fingerprints y `FlowEngine` deterministas).
- Migraciones mínimas disponibles en `crates/chem-persistence/migrations` (ajustables en este F5).

Entregables (Definition of Done):
1) Migración transaccional inicial aplicada automáticamente (event_log + artifacts opcional) y documentada.
2) `PgEventStore` y `PgFlowRepository` funcionales con transacciones atómicas donde corresponda.
3) Suite de tests de paridad y round-trip verde (incluye fingerprint final y secuencias compactas).
4) Índices clave creados (al menos `(flow_id, seq)`); secundarios grandes marcados como diferidos.
5) Manejo básico de errores transitorios: reintento simple con backoff.
6) Tipos correctos en columnas (UUID, timestamptz, JSONB, BIGSERIAL/IDENTITY).
7) Snapshot de esquema y notas de operabilidad (backup/restore, constraints) en documentación.

Plan detallado (paso a paso):

Fase 0 — Wiring y entorno
- [ ] Verificar `DATABASE_URL` exportado y conexión (psql o cliente). 
- [ ] Si no hay DB local, levantar contenedor con el compose incluido.
- [ ] Alinear versión de Diesel/driver y features de `chem-persistence` (sin agregar dependencias innecesarias).

Fase 1 — Migración transaccional inicial (idempotente)
- [ ] Consolidar migraciones en `crates/chem-persistence/migrations` con aplicación transaccional:
  - Tabla `event_log` (append-only):
    - `seq BIGSERIAL PRIMARY KEY`
    - `flow_id UUID NOT NULL`
    - `ts TIMESTAMPTZ NOT NULL DEFAULT now()`
    - `event_type TEXT NOT NULL CHECK (lower(event_type) IN (...tipos permitidos...))`
    - `payload JSONB NOT NULL`
  - Índice: `CREATE INDEX idx_event_log_flow_seq ON event_log(flow_id, seq);`
  - (Opcional) `workflow_step_artifacts` para deduplicación por hash:
    - `artifact_hash TEXT PRIMARY KEY CHECK (length(artifact_hash)=64)`
    - `produced_in_seq BIGINT NOT NULL REFERENCES event_log(seq) ON DELETE RESTRICT`
    - Índice auxiliar `idx_artifacts_seq`.
- [ ] Usar `CREATE EXTENSION IF NOT EXISTS pgcrypto;` si se requiere en el entorno.
- [ ] Garantizar idempotencia (`IF NOT EXISTS`) y transacción en la aplicación.

Fase 2 — Implementaciones Postgres (stores/repos)
- [ ] `PgEventStore`:
  - [ ] `append_kind(flow_id, FlowEventKind) -> FlowEvent`:
    - Serializar `FlowEventKind` → JSONB estable en `payload` + set `event_type` en minúsculas.
    - Insertar en una única transacción; devolver `seq` y `ts` de la DB.
  - [ ] `list(flow_id) -> Vec<FlowEvent>`:
    - `SELECT ... WHERE flow_id = $1 ORDER BY seq ASC` y deserializar.
- [ ] `PgFlowRepository`:
  - [ ] Reutilizar la lógica de replay existente (in-memory) para paridad; evitar duplicar reglas.
  - [ ] API: `load(flow_id, &events, &definition) -> FlowInstance`.
- [ ] Aislamiento de mapeos (dominio↔filas) en módulo `pg/` dedicado; no filtrar lógica del core.

Fase 3 — Transacciones atómicas y consistencia
- [ ] Asegurar que las operaciones que combinan "persistencia de artifacts" + "evento StepFinished" sean atómicas cuando el feature de artifacts esté activo.
- [ ] Confirmar que no existan rutas de UPDATE/DELETE sobre `event_log` (append-only).

Fase 4 — Índices e higiene de consultas
- [ ] Índice obligatorio: `(flow_id, seq)` en `event_log`.
- [ ] Secundarios (diferidos): índices por `event_type`, índices parciales para consultas específicas.
- [ ] Verificar planes de ejecución sobre consultas críticas.

Fase 5 — Errores transitorios y reintento simple
- [ ] Definir errores transitorios comunes (timeouts, deadlocks detectados por código SQLSTATE, desconexiones breves).
- [ ] Implementar wrapper de reintento con backoff exponencial pequeño (p. ej., 3 intentos, jitter minúsculo) en `append` y `list`.
- [ ] Registrar métricas ligeras o logs de reintentos (sin introducir dependencias pesadas).

Fase 6 — Tipos y serialización estable
- [ ] Confirmar tipos exactos:
  - `flow_id` = `UUID`
  - `ts` = `TIMESTAMPTZ`
  - `payload` = `JSONB` (con nombres de campos estables)
  - `seq` = `BIGSERIAL` (o `GENERATED BY DEFAULT AS IDENTITY`)
- [ ] Validar que `event_type` respete el conjunto permitido y se derive de forma estable del enum.
- [ ] Asegurar que la serialización del enum y fingerprints no cambian al cambiar el orden de campos (usar orden canónico en JSON).

Fase 7 — Tests de paridad y determinismo (must pass)
- [ ] Paridad InMemory vs Postgres:
  - Correr flujo simple determinista → comparar `event_variants` y `flow_fingerprint` entre backends.
- [ ] Round‑trip exhaustivo del enum de eventos (serialización/deserialización DB).
- [ ] Contigüidad de `seq` por flujo (orden total; sin huecos visibles para ese `flow_id`).
- [ ] Deduplicación de artifacts (si tabla habilitada) y FK a `event_log`.
- [ ] Reintentos no rompen determinismo (mismos contenidos; sólo varía latencia).

Fase 8 — Documentación y snapshot de esquema
- [ ] Exportar snapshot SQL efectivo en `documentation/snapshots/` (p. ej., `schema_f5.sql`).
- [ ] Documentar supuestos operativos: retención, backup/restore, tamaño esperado, costos de índices.
- [ ] Anotar procedimientos de migración futuros (añadir columnas/índices sin downtime cuando sea posible).

Fase 9 — Tareas de integración y DX
- [ ] Atajos en `FlowEngine` para operar con stores custom (ya presentes): `builder(event_store, repository)` y lecturas sin `flow_id`.
- [ ] Scripts utilitarios (opcional): `dev_db.sh`, `dump_schema.sh` actualizados.
- [ ] `README` del crate `chem-persistence` con ejemplos de uso Postgres.

Checklist de verificación final (previo a cerrar F5):
- [ ] `cargo test -p chem-persistence` y `./test_all.sh` en verde.
- [ ] Ejecución de ejemplo dual (in-memory y Postgres) entrega mismo `flow_fingerprint`.
- [ ] `event_variants()` coinciden bit a bit entre backends.
- [ ] Índices creados y visibles; no hay seq scans peligrosos en consultas críticas.
- [ ] Reintentos activos y cubiertos por tests (simulación con errores inducidos si es posible).
- [ ] Snapshot `schema_f5.sql` generado y referencia en docs.

Notas/decisiones:
- Para asignación de `seq`, se delega a la DB (monotónico global). El orden por `flow_id, seq` garantiza replay consistente.
- Los artifacts son opcionales en F5; si se activan, su persistencia es append-only y referenciada por `seq` del evento productor.
- No se expone API que permita mutar o borrar eventos; recovery se basa en replay puro.
