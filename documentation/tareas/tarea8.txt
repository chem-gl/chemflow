### F8 – Persistencia Extendida de Errores

| Núcleo                                                                 | Contrato Estabilizado                          | GATE_F8                               | Paralelo Seguro                |
| ---------------------------------------------------------------------- | ---------------------------------------------- | ------------------------------------- | ------------------------------ |
| Migración STEP_EXECUTION_ERRORS, persistir retry_count/max_retries     | Esquema errores + attempt_number               | Rehidratación DB == memoria           | Métricas error (luego)         |

Objetivos Clave:

- Auditoría granular de fallos con persistencia de errores por step y attempt.
- Base para políticas avanzadas de retry y clasificación de errores (transient vs permanent).
- Mantener paridad entre memoria y DB para rehidratación de estado de errores.

Pasos sugeridos (bien implementados):

1. **Crear migración Diesel para tabla STEP_EXECUTION_ERRORS**:
   - En `crates/chem-persistence/migrations/`, crear nueva carpeta `0003_step_execution_errors/`.
   - Archivo `up.sql`: Crear tabla con campos: `id SERIAL PRIMARY KEY`, `flow_id UUID NOT NULL`, `step_id TEXT NOT NULL`, `attempt_number INTEGER NOT NULL`, `error_class TEXT NOT NULL`, `error_message TEXT`, `details JSONB`, `timestamp TIMESTAMPTZ DEFAULT NOW()`, `retry_count INTEGER DEFAULT 0`, `max_retries INTEGER DEFAULT 3`.
   - Índice compuesto: `CREATE INDEX idx_step_execution_errors_flow_step_attempt ON step_execution_errors(flow_id, step_id, attempt_number);`.
   - Archivo `down.sql`: `DROP TABLE step_execution_errors;`.

2. **Actualizar esquemas y modelos en chem-persistence**:
   - En `crates/chem-persistence/src/schema.rs`, agregar la nueva tabla usando Diesel macros.
   - Crear modelo `StepExecutionError` en `crates/chem-persistence/src/models.rs` con derives para `Queryable`, `Insertable`, etc.
   - Implementar funciones en `crates/chem-persistence/src/lib.rs` para insertar errores: `insert_step_execution_error(pool, error_data)`.

3. **Modificar FlowEngine para persistir errores**:
   - En `crates/chem-core/src/engine/mod.rs`, al emitir `StepFailed`, insertar en la tabla de errores usando el pool de Postgres.
   - Agregar campo `error_store: Option<PgErrorStore>` al `FlowEngine` para inyección opcional.
   - En `schedule_retry`, incrementar `retry_count` y persistir el nuevo attempt.

4. **Implementar clasificación de errores**:
   - Crear enum `ErrorClass` en `crates/chem-core/src/errors.rs`: `Transient`, `Permanent`, `Validation`, `Runtime`.
   - Función helper `classify_error(error: &CoreEngineError) -> ErrorClass` basada en tipo de error.
   - Persistir `error_class` en la tabla para que `RetryPolicy` pueda leerla.

5. **Actualizar rehidratación (FlowRepository)**:
   - En `crates/chem-persistence/src/pg.rs`, modificar `load` para incluir errores del step desde la DB.
   - Asegurar que `StepSlot` tenga `retry_count` y lista de errores históricos.
   - Verificar paridad: replay desde DB debe dar mismo estado que memoria.

6. **Tests de reconstrucción timeline**:
   - En `crates/chem-persistence/tests/`, agregar test `test_error_timeline_reconstruction`.
   - Simular flujo con fallos, persistir, rehidratar y verificar que `retry_count` y errores estén correctos.
   - Usar `cargo test --package chem-persistence` para validar.

7. **Consultas para verificación de counts**:
   - Agregar funciones en `crates/chem-persistence/src/queries.rs`: `count_errors_by_flow(flow_id)`, `get_error_timeline(flow_id, step_id)`.
   - En `src/main.rs`, agregar ejemplo de uso: imprimir counts de errores tras ejecución.

8. **Documentación y formato details JSON**:
   - En `crates/chem-persistence/README.md`, documentar esquema de `details` JSON: `{"stack_trace": "...", "input_hash": "...", "params": {...}}`.
   - Agregar ejemplos de queries SQL para auditoría.

GATE_F8:

- Timeline de errores exacto: rehidratación DB incluye todos los errores históricos por attempt.
- RetryPolicy puede leer clasificación: `ErrorClass` se usa para decidir si retry es viable.

---

## Diagramas

### Diagrama de Clases (F8)

```mermaid
classDiagram
	class FlowEngine {
		+schedule_retry(flow_id, def, step_id, reason, max)
		+emit_step_failed(error)
	}
	class PgErrorStore {
		+insert_error(error_data)
		+list_errors(flow_id, step_id)
	}
	class StepExecutionError {
		+flow_id: UUID
		+step_id: String
		+attempt_number: u32
		+error_class: ErrorClass
		+details: Json
		+retry_count: u32
	}
	class ErrorClass {
		<<enum>>
		+Transient
		+Permanent
		+Validation
		+Runtime
	}
	class RetryPolicy {
		+should_retry(error_class, retry_count)
	}
	FlowEngine --> PgErrorStore : persiste errores
	FlowEngine --> RetryPolicy : consulta clasificación
	PgErrorStore --> StepExecutionError : inserta
	RetryPolicy --> ErrorClass : usa
```

### Diagrama de Flujo (F8)

```mermaid
flowchart LR
	A[StepFailed] --> B[Classify Error]
	B --> C{Transient?}
	C -- Sí --> D[Schedule Retry]
	C -- No --> E[Mark Permanent]
	D --> F[Insert Error DB]
	F --> G[Increment retry_count]
	G --> H[Re-run Step]
	H --> I[Success/Fail]
	I -- Fail --> A
	I -- Success --> J[FlowCompleted]
	E --> K[No Retry]
```

Notas:

- La tabla `STEP_EXECUTION_ERRORS` es append-only, similar a `event_log`.
- `attempt_number` permite reconstruir timeline exacto de fallos por step.
- `RetryPolicy` usa `error_class` para decidir retries sin alterar fingerprints.

---