// ============================================================================
//                        SISTEMA DE FLUJOS (PSEUDOCÓDIGO RUST)
// ============================================================================
//
// Objetivo:
// - Modelar flujos secuenciales con Steps fuertemente tipados.
// - Cada FlowDefinido declara SU PROPIO conjunto de pasos (enum de pasos).
// - El motor garantiza: secuencia, validación de parámetros antes de ejecutar,
//   trazabilidad inmutable (event sourcing), branching tipo Git y reportes.
//
// Nota: Este archivo NO implementa lógica; solo describe qué debe hacer cada
//       pieza con comentarios detallados.
// ============================================================================
// - Cada Flow inicializa TODOS sus Steps en el constructor.
// - Cada Step tiene su propio UUID.
// - Los enerados solo son accesibles si el Step está Completed.
// - estos datos son accesibles directamente por la estructura con sus metodos
// - La trazabilidad sigue siendo event-sourcing inmutable.
// ============================================================================

// ============================================================================
//                         SISTEMA DE ERRORES
// ============================================================================
#[derive(Error, Debug, Serialize, Deserialize)]
enum FlowError {
    #[error("Validation error: {0}")]
    Validation(#[from] ValidationErrors),

    #[error("Step execution failed: {0}")]
    StepFailure(String),

    #[error("Persistence error: {0}")]
    Persistence(String),

    #[error("Step not found: {0}")]
    StepNotFound(Uuid),
}

#[derive(Error, Debug)]
enum StepError {
    #[error("Validation error: {0}")]
    Validation(#[from] ValidationErrors),

    #[error("Execution error: {0}")]
    Execution(String),

    #[error("Timeout error")]
    Timeout,
}

// ============================================================================
//                         ESTADOS DE EJECUCIÓN
// ============================================================================
enum Status {
    Pending,
    Running,
    Completed,
    Failed(String),
    Skipped,
    Cancelled,
}

// ============================================================================
//                         EVENTOS DEL FLOW
// ============================================================================
#[derive(Clone, Debug, Serialize, Deserialize)]
enum FlowEventType {
    StepStarted,
    StepCompleted,
    StepFailed(String),
    StepSkipped(String),
    BranchCreated,
    UserInteractionRequired,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct FlowEvent {
    event_id: Uuid,
    flow_uuid: Uuid,
    step_uuid: Option<Uuid>,
    event_type: FlowEventType,
    timestamp: u64,
    metadata: serde_json::Value,
}


// ============================================================================
//                          TRAIT GENÉRICO STEP
// ============================================================================
/// Contrato común para todos los Steps.
/// - Cada Step debe tener un UUID único, un nombre y un estado.
/// - Debe validar sus parámetros antes de ejecutarse.
/// - Debe tener un método para ejecutar la lógica del paso.
 /// guardar totalmente su trazabilidad.
/// si durante la ejecución del paso se necesita acceder a datos de pasos anteriores, esto debe hacerse de manera segura y tipada.
/// si se necesita interaccionar con el usuario, esto debe hacerse a través de un mecanismo de eventos, cuando este en estado pendiente por ejemplo
/// y si toma una decision el usuario esta debe ser totalmente capturada para su trazabilidad todo aqui debe poder ser reproducible cuando se clone
#[async_trait]
trait Step {
    fn new(name: String) -> Self where Self: Sized;
    fn from_db(uuid: Uuid) -> Option<Self> where Self: Sized;
    fn uuid(&self) -> Uuid;            // UUID único del Step
    fn name(&self) -> &str;            // Nombre humano/técnico
    fn step_status(&self) -> Status;  // Estado actual
    fn validate_params(&self) -> Result<(), ValidationErrors>;// Verifica parámetros antes de ejecutar 
    async fn execute(&mut self, input: Option<Self::Input>) -> Result<Self::Output, StepError>;// Ejecuta el Step
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send>;
}
// ============================================================================
//                     TRAIT FLOW (GENÉRICO)
// ============================================================================
#[async_trait]
trait Flow {
    type StepEnum;
    //funcion que te permita recuperar un flow por su uuid de la base de datos tambien debe verificar si efectivamente es el tipo 
    fn get_flow_by_uuid(uuid: Uuid) -> Option<Self> where Self: Sized;
    fn new(name: String) -> Self where Self: Sized;
    //regresa un step
    fn step(&self, index: usize) -> Option<&Self::StepEnum>;
    /// Identidad del Flow
    fn uuid(&self) -> Uuid;
        /// Flow padre si es branch
    fn parent_uuid(&self) -> Option<Uuid>;
        /// Número total de pasos
    fn steps_len(&self) -> usize;
        /// Índice actual
    fn current_index(&self) -> Option<usize>;
        /// Ejecuta el siguiente step (valida estados y parámetros)
    fn step_status(&self, index: usize) -> Status;
    
    fn run_next_step(&mut self);
    
    /// Ejecuta el siguiente step y espera a que termine
    fn run_next_step_and_wait(&mut self);
    fn new_branch(&self, up_to_index: usize) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send>;
    fn clone_box(&self) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send>;
    fn events(&self) -> &[FlowEvent];

    // ---------------------------
    // EVENT HANDLER
    // ---------------------------
    /// Registra un callback que se disparará cada vez que ocurra un evento
    /// en el Flow o en cualquiera de sus Steps.
    fn set_event_handler(&mut self, handler: EventCallback);
    /// Internamente, cada Flow concreto llamará a este método para disparar
    /// eventos a quien se haya suscrito.
    fn emit_event(&self, step_uuid: Option<Uuid>, event_type: FlowEventType);
}





























// ============================================================================
// EJEMPLO DE STEPS
// ============================================================================

#[derive(Debug)]
struct StepA { uuid: Uuid, name: String, status: Status }
#[derive(Debug)]
struct StepB { uuid: Uuid, name: String, status: Status }
#[derive(Debug)]
struct StepC { uuid: Uuid, name: String, status: Status }

#[async_trait]
impl Step for StepA {
    fn new(name: String) -> Self {
        StepA { uuid: Uuid::new_v4(), name, status: Status::Pending }
    }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.name }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> { 
        self.status = Status::Completed; 
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(StepA { uuid: Uuid::new_v4(), name: self.name.clone(), status: Status::Pending })
    }
}

#[async_trait]
impl Step for StepB {
    fn new(name: String) -> Self { StepB { uuid: Uuid::new_v4(), name, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.name }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> { 
        self.status = Status::Completed; 
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(StepB { uuid: Uuid::new_v4(), name: self.name.clone(), status: Status::Pending })
    }
}

#[async_trait]
impl Step for StepC {
    fn new(name: String) -> Self { StepC { uuid: Uuid::new_v4(), name, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.name }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> { 
        self.status = Status::Completed; 
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(StepC { uuid: Uuid::new_v4(), name: self.name.clone(), status: Status::Pending })
    }
}
impl StepC {
    fn inserta_parametros(&mut self, _parametros: Vec<String>) {
        // Lógica interna exclusiva de StepC
    }
}

// ============================================================================
// ENUM DE STEPS PARA EL FLOW
// ============================================================================
#[derive(Debug)]
enum EjemploFlowStep {
    A(StepA),
    B(StepB),
    C(StepC),
}
impl EjemploFlowStep {
    fn get_nombre(&self) -> &str {
        match self {
            EjemploFlowStep::A(step) => step.name(),
            EjemploFlowStep::B(step) => step.name(),
            EjemploFlowStep::C(step) => step.name(),
        }
    }
    fn get_status(&self) -> &Status {
        match self {
            EjemploFlowStep::A(step) => step.step_status(),
            EjemploFlowStep::B(step) => step.step_status(),
            EjemploFlowStep::C(step) => step.step_status(),
        }
    }
    fn get_uuid(&self) -> Uuid {
        match self {
            EjemploFlowStep::A(step) => step.uuid(),
            EjemploFlowStep::B(step) => step.uuid(),
            EjemploFlowStep::C(step) => step.uuid(),
        }
    }
}

// ============================================================================
// IMPLEMENTACIÓN DEL FLOW
// ============================================================================
struct EjemploFlow {
    uuid: Uuid,
    steps: Vec<EjemploFlowStep>,
    current: usize,
    events: Vec<FlowEvent>,
}

#[async_trait]
impl Flow for EjemploFlow {
    type StepEnum = EjemploFlowStep;

    fn get_flow_by_uuid(_uuid: Uuid) -> Option<Self> { 
         // 1. Consultar DB por flow con ese UUID
        // 2. Si existe, reconstruir EjemploFlow con Steps y estados
        // 3. Retornar Some(flow) o None si no existe
     }
    fn new(_name: String) -> Self {
        EjemploFlow {
            uuid: Uuid::new_v4(),
            steps: vec![
                EjemploFlowStep::A(StepA::new("Step A".into())),
                EjemploFlowStep::B(StepB::new("Step B".into())),
                EjemploFlowStep::C(StepC::new("Step C".into())),
            ],
            current: 0,
            events: vec![],
        }
    }

    fn step(&self, index: usize) -> Option<&Self::StepEnum> {
        self.steps.get(index)
        
    }

    fn inserta_parametros_c(&mut self, _parametros: Vec<String>) {
        if let Some(EjemploFlowStep::C(step)) = self.steps.get_mut(2) {
            step.inserta_parametros(_parametros);
        }
    }

    fn uuid(&self) -> Uuid { self.uuid }
    fn parent_uuid(&self) -> Option<Uuid> { None }
    fn steps_len(&self) -> usize { self.steps.len() }
    fn current_index(&self) -> Option<usize> { Some(self.current) }
    fn step_status(&self, index: usize) -> Status {
        match self.steps.get(index) {
            Some(EjemploFlowStep::A(s)) => s.step_status(),
            Some(EjemploFlowStep::B(s)) => s.step_status(),
            Some(EjemploFlowStep::C(s)) => s.step_status(),
            None => Status::Pending,
        }
    }

    fn run_next_step(&mut self) {
     
            // 0) Determinar el índice del siguiente paso a ejecutar (cursor).
            // 1) Verificar que el anterior (si existe) esté Completed; si no, abortar.
            // si se necesita obtener datos del paso anterior aqui los obtengo ya que termino y se los paso al siguiente para que pase su validacion
            // ya que hay dos formas de llenar los parametros de un step y esto lo definira cada step como le convenga uno sera directamente desde
            // en este caso EjemploFlow que tendra funciones para insertar los daos que necesite o aqui donde llamare una funcion que llenara
            // los datos del siguiente paso
            // 2) Verificar `validate_params()` del paso actual.
            //    - Si false: NO ejecutar; registrar incidente (y opcionalmente marcar Skipped, o Aborted).
            // 3) push_event(StepStarted), marcar Running (si se cachea).
            // 4) Llamar `run()` del Step dentro del match del enum:
            //      match self.steps[i] { Ingesta(s) => s.run(), Transforma(s) => s.run(), ... }
            // 5) Si Ok:
            //      - Congelar outputs (persistir, hash, metadata).
            //      - push_event(StepCompleted).
            //      - advance_cursor().
            // 6) Si Err(e):
            //      - push_event(StepFailed con `e`).
            //      - NO avanzar cursor.
            //      - Dejar evidencia para retry manual/automático.
            // 7) Notificar a subsistemas (reportes, UI, alertas).
           

            self.current += 1;
    
    }

    fn run_next_step_and_wait(&mut self) { self.run_next_step(); }
    fn new_branch(&self, _up_to_index: usize) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> { 
        // 1. Validar que _up_to_index Completed
        // 2. Clonar Steps y outputs hasta ese índice
        // 3. Crear nuevo UUID y parent_uuid = self.uuid
        // 4. Registrar evento BranchCreated
    }
    fn clone_box(&self) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> { 
        Box::new(Self::new("clone".into())) 
    }
    fn events(&self) -> &[FlowEvent] { &self.events }

    fn set_event_handler(&mut self, _handler: EventCallback) {
    
    }
    fn emit_event(&self, _step_uuid: Option<Uuid>, _event_type: FlowEventType) {
        // 1. Crear FlowEvent con timestamp y detalles
        // 2. Append a self.events
        // 3. Persistir en DB
        // 4. Llamar event_handler si existe
    }
}



// ============================================================================
//  SEGUNDO EJEMPLO: OTRO FLOW (Ingesta -> Limpieza -> Feature Engineering)
// ============================================================================
// Objetivo de este segundo ejemplo:
// - Mostrar cómo se reutiliza el trait Step y el trait Flow para definir OTRO
//   flujo totalmente distinto al anterior sin tocar el primero.
// - Mantener la misma filosofía: enum central con TODOS los Steps concretos.
// - Explicar (en comentarios) qué debería ocurrir en cada método real.
// - NO es código funcional completo; faltan validaciones, persistencia,
//   control de concurrencia, timeouts, etc.
// ----------------------------------------------------------------------------

// -----------------------------
// STEPS DEL SEGUNDO FLOW
// -----------------------------
#[derive(Debug)]
struct IngestaArchivo { uuid: Uuid, nombre: String, status: Status /*, campos_parametros, buffers, etc. */ }
#[derive(Debug)]
struct LimpiezaDatos { uuid: Uuid, nombre: String, status: Status /*, reglas, expresiones, etc. */ }
#[derive(Debug)]
struct GeneraMatrizFeaturizada { uuid: Uuid, nombre: String, status: Status /*, config de ingeniería de features */ }

// NOTA: Se recicla exactamente el mismo trait Step. Cada implementación real
// haría sus validaciones y ejecución asíncrona. Aquí sólo se comentan ideas.
#[async_trait]
impl Step for IngestaArchivo {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { /* Reconstruir desde eventos/tabla */ None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Verificar existencia de ruta de archivo, permisos, tamaño, formato.
        // Retornar Err si algo crítico falta.
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Leer archivo (streaming / chunked en implementación real)
        // 2. Hacer checksum y registrar metadatos (evento)
        // 3. Persistir crudo si aplica
        // 4. Marcar Completed al final
        self.status = Status::Completed;
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending })
    }
}

#[async_trait]
impl Step for LimpiezaDatos {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Validar que existe output del paso anterior (IngestaArchivo) y
        // que cumple mínimos (no vacío, formato válido, etc.).
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // Aplicar reglas: normalización, trimming, eliminación de duplicados.
        // Registrar stats (conteo de filas antes / después, % nulos, etc.).
        self.status = Status::Completed;
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending })
    }
}

#[async_trait]
impl Step for GeneraMatrizFeaturizada {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Confirmar que los datos limpios existen y que la config de features
        // (p.ej. lista de columnas derivadas) es consistente.
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Generar columnas derivadas
        // 2. Calcular hashes / fingerprint para reproducibilidad
        // 3. Persistir matriz final
        self.status = Status::Completed;
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> {
        Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending })
    }
}

// -----------------------------
// ENUM DEL SEGUNDO FLOW
// -----------------------------
#[derive(Debug)]
enum DataPrepFlowStep {
    Ingesta(IngestaArchivo),
    Limpieza(LimpiezaDatos),
    Features(GeneraMatrizFeaturizada),
}

impl DataPrepFlowStep {
    // Helpers de acceso (mismo patrón que el primer ejemplo)
    fn uuid(&self) -> Uuid { match self { Self::Ingesta(s) => s.uuid(), Self::Limpieza(s) => s.uuid(), Self::Features(s) => s.uuid() } }
    fn status(&self) -> Status { match self { Self::Ingesta(s) => s.step_status(), Self::Limpieza(s) => s.step_status(), Self::Features(s) => s.step_status() } }
    fn nombre(&self) -> &str { match self { Self::Ingesta(s) => s.name(), Self::Limpieza(s) => s.name(), Self::Features(s) => s.name() } }
}

// -----------------------------
// DEFINICIÓN DEL SEGUNDO FLOW
// -----------------------------
struct DataPrepFlow {
    uuid: Uuid,
    parent: Option<Uuid>,
    pasos: Vec<DataPrepFlowStep>,
    cursor: usize,
    eventos: Vec<FlowEvent>,
    // event_handler: Option<EventCallback>, // Igual que en el primero
}

#[async_trait]
impl Flow for DataPrepFlow {
    type StepEnum = DataPrepFlowStep;

    fn get_flow_by_uuid(_uuid: Uuid) -> Option<Self> { /* Reconstrucción desde DB (event sourcing) */ None }
    fn new(_nombre: String) -> Self {
        DataPrepFlow {
            uuid: Uuid::new_v4(),
            parent: None,
            pasos: vec![
                DataPrepFlowStep::Ingesta(IngestaArchivo::new("Ingesta crudo".into())),
                DataPrepFlowStep::Limpieza(LimpiezaDatos::new("Limpieza dataset".into())),
                DataPrepFlowStep::Features(GeneraMatrizFeaturizada::new("Feature matrix".into())),
            ],
            cursor: 0,
            eventos: vec![],
        }
    }
    fn step(&self, index: usize) -> Option<&Self::StepEnum> { self.pasos.get(index) }
    fn uuid(&self) -> Uuid { self.uuid }
    fn parent_uuid(&self) -> Option<Uuid> { self.parent }
    fn steps_len(&self) -> usize { self.pasos.len() }
    fn current_index(&self) -> Option<usize> { Some(self.cursor) }
    fn step_status(&self, index: usize) -> Status { self.pasos.get(index).map(|s| s.status()).unwrap_or(Status::Pending) }
    fn run_next_step(&mut self) {
        // MISMA SECUENCIA CONCEPTUAL que en el primer Flow (ver comentarios allí):
        // 0) Validar índice actual.
        // 1) Confirmar que si cursor > 0 el paso anterior terminó en Completed.
        // 2) Validar parámetros del paso actual (p.ej. existencia de outputs previos).
        // 3) Emitir evento StepStarted.
        // 4) Ejecutar (async) y capturar resultado.
        // 5) Según resultado: StepCompleted o StepFailed + rollback si aplica.
        // 6) Avanzar cursor SOLO si Completed.
        // 7) Persistir evento y cualquier metadata de reproducibilidad.
        self.cursor += 1; // PLACEHOLDER (no real)
    }
    fn run_next_step_and_wait(&mut self) { self.run_next_step(); }
    fn new_branch(&self, _up_to_index: usize) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> {
        // Clonar estado hasta cierto índice para experimentos divergentes.
        Box::new(Self::new("branch".into()))
    }
    fn clone_box(&self) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> { Box::new(Self::new("clone".into())) }
    fn events(&self) -> &[FlowEvent] { &self.eventos }
    fn set_event_handler(&mut self, _handler: EventCallback) { /* almacenar callback */ }
    fn emit_event(&self, _step_uuid: Option<Uuid>, _event_type: FlowEventType) { /* similar al primer ejemplo */ }
}


// ============================================================================
//  TERCER EJEMPLO: FLOW CON INTERACCIÓN HUMANA Y BRANCHING
// ============================================================================
// Escenario: Un flujo científico donde antes de ejecutar una simulación costosa
// se requiere validación/aprobación manual de parámetros generados.
// Steps:
//   1. PreparaParametros -> genera un conjunto candidato.
//   2. EsperaAprobacionUsuario -> queda en Pending hasta que un usuario aprueba.
//   3. EjecutaSimulacion -> corre cómputo intensivo (HPC / cluster / GPU).
//   4. GeneraReporte -> consolida resultados y emite artefactos.
// Puntos clave mostrados en comentarios:
//   - Cómo un Step puede pausar el flujo (estado Pending) a la espera de input externo.
//   - Emisión de evento UserInteractionRequired.
//   - Posible branching justo DESPUÉS de la simulación para explorar variantes de reporte.
// ---------------------------------------------------------------------------

#[derive(Debug)]
struct PreparaParametros { uuid: Uuid, nombre: String, status: Status /* campos: rng_seed, ranges, etc. */ }
#[derive(Debug)]
struct EsperaAprobacionUsuario { uuid: Uuid, nombre: String, status: Status /* campos: propuesta_serializada */ }
#[derive(Debug)]
struct EjecutaSimulacion { uuid: Uuid, nombre: String, status: Status /* campos: recursos, job_id */ }
#[derive(Debug)]
struct GeneraReporte { uuid: Uuid, nombre: String, status: Status /* campos: paths de resultados */ }

#[async_trait]
impl Step for PreparaParametros {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // Generar parámetros, serializar y registrar evento.
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

#[async_trait]
impl Step for EsperaAprobacionUsuario {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // Este Step NO completa automáticamente: emite UserInteractionRequired
        // y queda en Pending/Running hasta que un evento externo (aprobación)
        // dispare la transición a Completed en una implementación real.
        // Aquí solo comentario para ilustrar.
        Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

#[async_trait]
impl Step for EjecutaSimulacion {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Confirmar que parámetros aprobados existen (estatus del Step anterior).
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // En real: lanzar job distribuido y marcar Running hasta callback.
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

#[async_trait]
impl Step for GeneraReporte {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> { Ok(()) }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // Consolidar resultados, generar PDFs/JSON, hash de integridad.
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

#[derive(Debug)]
enum SimulacionFlowStep {
    Prepara(PreparaParametros),
    Aprobacion(EsperaAprobacionUsuario),
    Simulacion(EjecutaSimulacion),
    Reporte(GeneraReporte),
}

struct SimulacionFlow {
    uuid: Uuid,
    parent: Option<Uuid>,
    pasos: Vec<SimulacionFlowStep>,
    cursor: usize,
    eventos: Vec<FlowEvent>,
}

#[async_trait]
impl Flow for SimulacionFlow {
    type StepEnum = SimulacionFlowStep;
    fn get_flow_by_uuid(_uuid: Uuid) -> Option<Self> { None }
    fn new(_nombre: String) -> Self {
        SimulacionFlow {
            uuid: Uuid::new_v4(),
            parent: None,
            pasos: vec![
                SimulacionFlowStep::Prepara(PreparaParametros::new("Preparar parámetros".into())),
                SimulacionFlowStep::Aprobacion(EsperaAprobacionUsuario::new("Esperar aprobación".into())),
                SimulacionFlowStep::Simulacion(EjecutaSimulacion::new("Correr simulación".into())),
                SimulacionFlowStep::Reporte(GeneraReporte::new("Generar reporte".into())),
            ],
            cursor: 0,
            eventos: vec![],
        }
    }
    fn step(&self, index: usize) -> Option<&Self::StepEnum> { self.pasos.get(index) }
    fn uuid(&self) -> Uuid { self.uuid }
    fn parent_uuid(&self) -> Option<Uuid> { self.parent }
    fn steps_len(&self) -> usize { self.pasos.len() }
    fn current_index(&self) -> Option<usize> { Some(self.cursor) }
    fn step_status(&self, _index: usize) -> Status { /* similar a otros */ Status::Pending }
    fn run_next_step(&mut self) {
        // Igual secuencia conceptual. Especial atención al segundo Step:
        // - Si es Aprobacion y no hay decisión todavía -> no avanzar.
        // - Cuando llega el input externo -> transición a Completed + evento.
        self.cursor += 1; // placeholder
    }
    fn run_next_step_and_wait(&mut self) { self.run_next_step(); }
    fn new_branch(&self, _up_to_index: usize) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> {
        // Podría branch-ear justo después de Simulacion para generar múltiples
        // variantes de reporte (diferentes plantillas) sin repetir cómputo.
        Box::new(Self::new("branch".into()))
    }
    fn clone_box(&self) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> { Box::new(Self::new("clone".into())) }
    fn events(&self) -> &[FlowEvent] { &self.eventos }
    fn set_event_handler(&mut self, _handler: EventCallback) { /* almacenar */ }
    fn emit_event(&self, _step_uuid: Option<Uuid>, _event_type: FlowEventType) { /* registrar */ }
}


// ============================================================================
//  CUARTO EJEMPLO: FLUJO PARA DESCUBRIMIENTO / PREPARACIÓN DE ANTIOXIDANTES
// ============================================================================
// Objetivo: Ilustrar un flujo orientado a dominio químico usando providers ya
// existentes (molecule, properties, data) para construir un pipeline típico:
//   1. Generar familias semilla de moléculas antioxidantes (MoleculeProvider)
//   2. Calcular propiedades antioxidantes (PropertiesProvider)
//   3. Agregar métricas y estadísticas (DataProvider)
//   4. Seleccionar candidatos finales (heurísticas o ranking)
// NOTA: Igual que los demás, es pseudocódigo; las llamadas reales a providers
// se documentan en comentarios para guiar la implementación futura.
// ----------------------------------------------------------------------------

// -----------------------------
// STEPS DEL FLUJO ANTIOXIDANTE
// -----------------------------
#[derive(Debug)]
struct GeneraSemillasAntiox { uuid: Uuid, nombre: String, status: Status /* campos: params del provider, familia generada */ }
#[derive(Debug)]
struct CalculaPropiedadesAntiox { uuid: Uuid, nombre: String, status: Status /* campos: referencia a familia, lista de propiedades calculadas */ }
#[derive(Debug)]
struct AgregaEstadisticasAntiox { uuid: Uuid, nombre: String, status: Status /* campos: json agregaciones */ }
#[derive(Debug)]
struct SeleccionaTopAntiox { uuid: Uuid, nombre: String, status: Status /* campos: ranking, filtros aplicados */ }

// Paso 1: Usa AntioxidantSeedProvider (providers::molecule::implementations::antioxidant_seed_provider)
#[async_trait]
impl Step for GeneraSemillasAntiox {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None /* reconstruir a partir de eventos (familia serializada) */ }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Verificar parámetros para AntioxidantSeedProvider: include_phenolics, extra_seeds, etc.
        // Asegurar que cualquier SMILES adicional es sintácticamente válido (pre-chequeo opcional).
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Instanciar AntioxidantSeedProvider
        // 2. Preparar HashMap<String, Value> con parámetros (posible override de defaults)
        // 3. Invocar get_molecule_family() -> MoleculeFamily
        // 4. Guardar familia serializada + referencia provider en eventos (provenance)
        // 5. Marcar Completed
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

// Paso 2: Usa AntioxidantActivityPropertiesProvider (providers::properties::implementations)
#[async_trait]
impl Step for CalculaPropiedadesAntiox {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Confirmar que el Step anterior (GeneraSemillasAntiox) está Completed y su familia existe.
        // Validar parámetros de scoring si hubiera (thresholds, seeds para RNG, etc.).
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Recuperar la familia generada (deserializar de eventos o caché interna del Flow)
        // 2. Instanciar AntioxidantActivityPropertiesProvider
        // 3. Calcular propiedades (scores) y agregarlas a la MoleculeFamily (propiedad radical_scavenging_score etc.)
        // 4. Registrar provider_reference en la propiedad para reproducibilidad
        // 5. Marcar Completed
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

// Paso 3: Usa AntioxidantAggregateProvider (providers::data::antioxidant_aggregate_provider)
#[async_trait]
impl Step for AgregaEstadisticasAntiox {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Chequear que las propiedades antioxidantes ya fueron calculadas.
        // Validar parámetros (ej: min_score) con defaults del provider.
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Instanciar AntioxidantAggregateProvider
        // 2. Construir parámetros (HashMap) incluyendo min_score si se definió
        // 3. Invocar calculate(&[familia], params) -> JSON con count, mean, etc.
        // 4. Almacenar JSON en evento (metadata) + versión del provider
        // 5. Marcar Completed
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

// Paso 4: Selección de candidatos (ranking/filtrado final)
#[async_trait]
impl Step for SeleccionaTopAntiox {
    fn new(nombre: String) -> Self { Self { uuid: Uuid::new_v4(), nombre, status: Status::Pending } }
    fn from_db(_uuid: Uuid) -> Option<Self> { None }
    fn uuid(&self) -> Uuid { self.uuid }
    fn name(&self) -> &str { &self.nombre }
    fn step_status(&self) -> Status { self.status.clone() }
    fn validate_params(&self) -> Result<(), ValidationErrors> {
        // Confirmar que estadísticas agregadas existen.
        // Validar parámetros como: top_k, min_mean_score, excluir_duplicados.
        Ok(())
    }
    async fn execute(&mut self, _input: Option<Self::Input>) -> Result<Self::Output, StepError> {
        // 1. Leer outputs previos (familia con scores + JSON agregaciones)
        // 2. Aplicar ranking (ordenar por score, filtrar por mean si corresponde)
        // 3. Serializar lista final de candidatos (IDs, SMILES, puntajes)
        // 4. Emitir evento final (Flow podría cerrarse o permitir branching).
        self.status = Status::Completed; Ok(())
    }
    fn clone_box(&self) -> Box<dyn Step<Input=Self::Input, Output=Self::Output> + Send> { Box::new(Self { uuid: Uuid::new_v4(), nombre: self.nombre.clone(), status: Status::Pending }) }
}

// -----------------------------
// ENUM DEL FLUJO ANTIOXIDANTE
// -----------------------------
#[derive(Debug)]
enum AntioxidantFlowStep {
    Semillas(GeneraSemillasAntiox),
    Propiedades(CalculaPropiedadesAntiox),
    Agrega(AgregaEstadisticasAntiox),
    Seleccion(SeleccionaTopAntiox),
}

impl AntioxidantFlowStep {
    fn uuid(&self) -> Uuid { match self { Self::Semillas(s) => s.uuid(), Self::Propiedades(s) => s.uuid(), Self::Agrega(s) => s.uuid(), Self::Seleccion(s) => s.uuid() } }
    fn status(&self) -> Status { match self { Self::Semillas(s) => s.step_status(), Self::Propiedades(s) => s.step_status(), Self::Agrega(s) => s.step_status(), Self::Seleccion(s) => s.step_status() } }
    fn nombre(&self) -> &str { match self { Self::Semillas(s) => s.name(), Self::Propiedades(s) => s.name(), Self::Agrega(s) => s.name(), Self::Seleccion(s) => s.name() } }
}

// -----------------------------
// DEFINICIÓN DEL FLOW ANTIOXIDANTE
// -----------------------------
struct AntioxidantDiscoveryFlow {
    uuid: Uuid,
    parent: Option<Uuid>,
    pasos: Vec<AntioxidantFlowStep>,
    cursor: usize,
    eventos: Vec<FlowEvent>,
}

#[async_trait]
impl Flow for AntioxidantDiscoveryFlow {
    type StepEnum = AntioxidantFlowStep;
    fn get_flow_by_uuid(_uuid: Uuid) -> Option<Self> { None /* reconstrucción futura */ }
    fn new(_nombre: String) -> Self {
        AntioxidantDiscoveryFlow {
            uuid: Uuid::new_v4(),
            parent: None,
            pasos: vec![
                AntioxidantFlowStep::Semillas(GeneraSemillasAntiox::new("Generar semillas".into())),
                AntioxidantFlowStep::Propiedades(CalculaPropiedadesAntiox::new("Calcular propiedades".into())),
                AntioxidantFlowStep::Agrega(AgregaEstadisticasAntiox::new("Agregar estadísticas".into())),
                AntioxidantFlowStep::Seleccion(SeleccionaTopAntiox::new("Seleccionar top candidatos".into())),
            ],
            cursor: 0,
            eventos: vec![],
        }
    }
    fn step(&self, index: usize) -> Option<&Self::StepEnum> { self.pasos.get(index) }
    fn uuid(&self) -> Uuid { self.uuid }
    fn parent_uuid(&self) -> Option<Uuid> { self.parent }
    fn steps_len(&self) -> usize { self.pasos.len() }
    fn current_index(&self) -> Option<usize> { Some(self.cursor) }
    fn step_status(&self, index: usize) -> Status { self.pasos.get(index).map(|s| s.status()).unwrap_or(Status::Pending) }
    fn run_next_step(&mut self) {
        // Secuencia idéntica conceptual (ver primer flow):
        // 0) Verificar bounds y estado previo.
        // 1) Validar parámetros específicos del paso actual.
        // 2) Emitir StepStarted + guardar provider params si aplica.
        // 3) Ejecutar lógica (providers de molécula / propiedades / datos / ranking).
        // 4) Persistir outputs (familia serializada, propiedades, JSON agregaciones, lista candidatos).
        // 5) Emitir StepCompleted y avanzar cursor SOLO si Completed.
        // 6) Si error: StepFailed, registrar motivo, dejar posibilidad de retry.
        self.cursor += 1; // placeholder
    }
    fn run_next_step_and_wait(&mut self) { self.run_next_step(); }
    fn new_branch(&self, _up_to_index: usize) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> {
        // Permitir experimentar con distintos criterios de ranking sin repetir pasos 1-3.
        Box::new(Self::new("branch".into()))
    }
    fn clone_box(&self) -> Box<dyn Flow<StepEnum=Self::StepEnum> + Send> { Box::new(Self::new("clone".into())) }
    fn events(&self) -> &[FlowEvent] { &self.eventos }
    fn set_event_handler(&mut self, _handler: EventCallback) { /* almacenar callback para UI/monitoring */ }
    fn emit_event(&self, _step_uuid: Option<Uuid>, _event_type: FlowEventType) { /* registrar en eventos + persistencia */ }
}
